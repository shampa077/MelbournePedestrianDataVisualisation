<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SummerViz</title>

    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>

</head>
<body>

<svg class="canvas" width="960px" height="600px">

</svg>

<script>

    /**

    Render a half-donut based on the values in the data array

    minRadius: the minimum distance from the center that a 'minimum' value in the array will be
    xScale: either 1 or -1 depending on which 'side' of the circle you want to render
    data: two dimensional numeric array, one array being an array of minimum values, the other being an array of maximum values

    */
    function jaggedHalfDonut(xCenter, yCenter, minRadius, xScale, data) {

        points = [];

        //the radiun step for rotating around origin
        var step = Math.PI / 360.0;

        //we have to have initial rotatation of pi/2 as we want our helf-donut to be vertical, no horizontal
        var startAngle = Math.PI / 2.0;

        //rotate until we hit pi radians, plus our initial offset
        var maxAngle = (Math.PI + startAngle);

        for (var theta = startAngle; theta < maxAngle; theta += step) {

            //calculate our current step by dividing current angle by pi radians (that gives us a normalized % of how far we are through a half-rotation, 
            //multiply that by how many data points we have in our data array to get the index of the radius to show
            var currentStep = (theta - startAngle);
            var pointIndex = Math.floor(currentStep / Math.PI * data.length);

            //get the radius
            var r = data[pointIndex] + minRadius;

            //calulate the points
            var x = xCenter + (r * Math.cos(theta) * xScale);
            var y = yCenter - r * Math.sin(theta);

            //store to array
            points.push([x, y]);
        }

        return points;
    }

    /**
    circleByRadius will render points for a half circle

    xScale: either 1 or -1 depending on which 'side' of the circle you want to render
    */
    function circleByRadius(xCenter, yCenter, r, xScale) {

        points = [];

        var x, y, r2;

        r2 = r * r;
        for (x = 0; x <= r; x++) {
            y = (Math.sqrt(r2 - x * x) + 0.5);
            points.push([(xCenter + x * xScale), yCenter + y]);
        }

        for (x = r; x > 0; x--) {
            y = (Math.sqrt(r2 - x * x) + 0.5);
            points.push([(xCenter + x * xScale), yCenter - y]);
        }

        return points;
    }

    function simpleCircle(xCenter, yCenter, innerRadius) {
        points = [];
        return circleByRadius(xCenter, yCenter, innerRadius, 1).concat(circleByRadius(xCenter, yCenter, innerRadius, -1).reverse());
    }


    // dummy data to print a 'gear', doesn't really matter if min or max array is first
    var maxs = [40, 50, 40, 50, 40, 50, 40, 50, 40, 50, 90, 50, 40, 50, 40, 50, 40, 50, 40, 50, 40, 50, 40, 50];
    var mins = [0, 20, 10, 20, 10, 20, 10, 20, 10, 20, 10, 20, 10, 20, 10, 20, 10, 20, 10, 20, 10, 20, 10, 20];
    var hourData = [maxs, mins];
    
    var donutCenterX = 200;
    var donutCenterY = 200;
    var minimumDonutRadius = 70;


    //"hot" half donut

    var points = jaggedHalfDonut(donutCenterX, donutCenterY, minimumDonutRadius, 1, hourData[0])
                    .concat(jaggedHalfDonut(donutCenterX, donutCenterY, minimumDonutRadius, 1, hourData[1]).reverse());

    //we have to reverse the 'second' loop, whether that's min or max, as we are drawing a poly, going around once (e.g. clockwise), then looping back the other direction (e.g. counter-cw)
    var canvas = d3.select("svg")
    .append("svg:polygon")
    .attr("fill", "red")
    //.attr("stroke", "black")
    .attr("points", points);


    //"cold" half donut

    //we have to reverse the 'second' loop, whether that's min or max, as we are drawing a poly, going around once (e.g. clockwise), then looping back the other direction (e.g. counter-cw)
    var points = jaggedHalfDonut(donutCenterX, donutCenterY, minimumDonutRadius, -1, hourData[0])
                    .concat(jaggedHalfDonut(donutCenterX, donutCenterY, minimumDonutRadius, -1, hourData[1]).reverse());
    var canvas = d3.select("svg")
    .append("svg:polygon")
    .attr("fill", "blue")
    //.attr("stroke", "black")
    .attr("points", points);


    //reference circle in the middle

    points = simpleCircle(200, 200, 70);
    var canvas = d3.select("svg")
    .append("svg:polygon")
    .attr("fill", "grey")
    //.attr("stroke", "black")
    .attr("points", points);

</script>
</body>
</html>

